                  2   $LIST
0000              4   
0000              5   CLK           EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000              6   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave
0000              7   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000              8   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000              9   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             10   
0000             11   Time_Speed EQU 100
0000             12   
0000             13   BOOT_BUTTON equ P4.5
0000             14   Button1 equ P2.1
0000             15   Button2 equ P2.1
0000             16   Button3 equ P2.1
0000             17   Button4 equ P2.1
0000             18   
0000             19   
0000             20   SOUND_OUT equ P1.1
0000             21   UPDOWN equ P0.0
0000             22   OvenPin equ P2.2
0000             23   
0000             24   ; Reset vector
0000             25   org 0x0000
0000 02018F      26       ljmp main
0003             27   
0003             28   ; External interrupt 0 vector (not used in this code)
0003             29   org 0x0003
0003 32          30            reti
0004             31   
0004             32   ; Timer/Counter 0 overflow interrupt vector
000B             33   org 0x000B
000B 020115      34            ljmp Timer0_ISR
000E             35   
000E             36   ; External interrupt 1 vector (not used in this code)
0013             37   org 0x0013
0013 32          38            reti
0014             39   
0014             40   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             41   org 0x001B
001B 32          42            reti
001C             43   
001C             44   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             45   org 0x0023 
0023 32          46            reti
0024             47            
0024             48   ; Timer/Counter 2 overflow interrupt vector
002B             49   org 0x002B
002B 020131      50            ljmp Timer2_ISR
002E             51   
002E             52   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             53   dseg at 0x30
0030             54   
0030             55   
0030             56   BCD_counter:  ds 1 ;The BCD counter incrememted in the ISR and displayed in the main loop
0031             57   Count1ms:     ds 2 ;Used to determine when half second has passed
0033             58   
0033             59   mode: ds 1 ;display time mode=0, set time mode=1 or set alarm mode=2.
0034             60   
0034             61   Selected: ds 1 ;0 = hr, 1 = min, 2 = Am/Pm, 3 = Done
0035             62   
0035             63   PowerPercent: ds 1 ; 0 = 0%, 1 = 20% ... 5 = 100%
0036             64   
0036             65   TenthSeconds: ds 1
0037             66   Seconds: ds 1 ;Seconds
0038             67   Minutes: ds 1 ;Minutes
0039             68   
0039             69   AlarmSec: ds 1 ;Seconds Alarm
003A             70   AlarmMin: ds 1 ;Minutes Alarm
003B             71   
003B             72   
003B             73   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
003B             74   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             75   bseg
0000             76   seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             77   
0001             78   
002E             79   cseg
002E             80   ; These 'equ' must match the hardware wiring
002E             81   LCD_RS equ P3.2
002E             82   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E             83   LCD_E  equ P3.3
002E             84   LCD_D4 equ P3.4
002E             85   LCD_D5 equ P3.5
002E             86   LCD_D6 equ P3.6
002E             87   LCD_D7 equ P3.7
002E             88   
                 90   	$LIST
00DA             92   
00DA             93   ;1234567890123456    <- This helps determine the location of the counter
00DA             94   
00DA 20202020    95   Initial_Message:  db '     :  :       ', 0
     203A2020
     3A202020
     20202020
     00
00EB             96   
00EB 20202020    97   CLS: db '                ', 0
     20202020
     20202020
     20202020
     00
00FC             98   
00FC             99   ;---------------------------------;
00FC            100   ; Routine to initialize the ISR   ;
00FC            101   ; for timer 0                     ;
00FC            102   ;---------------------------------;
00FC            103   Timer0_Init:
00FC E589       104            mov a, TMOD
00FE 54F0       105            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
0100 4401       106            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
0102 F589       107            mov TMOD, a
0104 758CEA     108            mov TH0, #high(TIMER0_RELOAD)
0107 758AE8     109            mov TL0, #low(TIMER0_RELOAD)
010A            110            ; Set autoreload value
010A 75F4EA     111            mov RH0, #high(TIMER0_RELOAD)
010D 75F2E8     112            mov RL0, #low(TIMER0_RELOAD)
0110            113            ; Enable the timer and interrupts
0110 D2A9       114       setb ET0  ; Enable timer 0 interrupt
0112 D28C       115       setb TR0  ; Start timer 0
0114 22         116            ret
0115            117   
0115            118   ;---------------------------------;
0115            119   ; ISR for timer 0.  Set to execute;
0115            120   ; every 1/4096Hz to generate a    ;
0115            121   ; 2048 Hz square wave at pin P1.1 ;
0115            122   ;---------------------------------;
0115            123   Timer0_ISR:
0115            124            ;clr TF0  ; According to the data sheet this is done for us already.
0115 B291       125            cpl SOUND_OUT ; Connect speaker to P1.1!
0117 32         126            reti
0118            127   
0118            128   ;---------------------------------;
0118            129   ; Routine to initialize the ISR   ;
0118            130   ; for timer 2                     ;
0118            131   ;---------------------------------;
0118            132   Timer2_Init:
0118 75C800     133            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
011B 75CDA9     134            mov TH2, #high(TIMER2_RELOAD)
011E 75CC9A     135            mov TL2, #low(TIMER2_RELOAD)
0121            136            ; Set the reload value
0121 75CBA9     137            mov RCAP2H, #high(TIMER2_RELOAD)
0124 75CA9A     138            mov RCAP2L, #low(TIMER2_RELOAD)
0127            139            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0127 E4         140            clr a
0128 F531       141            mov Count1ms+0, a
012A F532       142            mov Count1ms+1, a
012C            143            ; Enable the timer and interrupts
012C D2AD       144       setb ET2  ; Enable timer 2 interrupt
012E D2CA       145       setb TR2  ; Enable timer 2
0130 22         146            ret
0131            147   
0131            148   ;---------------------------------;
0131            149   ; ISR for timer 2                 ;
0131            150   ;---------------------------------;
0131            151   Timer2_ISR:
0131 C2CF       152            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0133 B290       153            cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0135            154            
0135            155            ; The two registers used in the ISR must be saved in the stack
0135 C0E0       156            push acc
0137 C0D0       157            push psw
0139            158            
0139            159            ; Increment the 16-bit one mili second counter
0139 0531       160            inc Count1ms+0    ; Increment the low 8-bits first
013B E531       161            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
013D 7002       162            jnz Inc_Done
013F 0532       163            inc Count1ms+1
0141            164   
0141            165   Inc_Done:
0141            166            ; Check if second has passed
0141 E531       167            mov a, Count1ms+0
0143 B4642D     168            cjne a, #low(Time_Speed), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0146 E532       169            mov a, Count1ms+1
0148 B40028     170            cjne a, #high(Time_Speed), Timer2_ISR_done
014B            171            
014B            172            ;1000 milliseconds have passed.  Set a flag so the main program knows
014B D200       173            setb seconds_flag ;Let the main program know (Time_Speed) ms have passed
014D            174            
014D            175            ;cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
014D            176            
014D            177            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
014D E4         178            clr a
014E F531       179            mov Count1ms+0, a
0150 F532       180            mov Count1ms+1, a
0152            181            
0152            182            ;1/10 Second Increment
0152 E536       183            mov     a, TenthSeconds
0154 B40921     184       cjne         a, #0x9, IncTenthSeconds
0157 7400       185       mov          a, #0 
0159 D4         186       da           a
015A F536       187       mov          TenthSeconds, a
015C            188            
015C            189            ;Seconds Increment
015C E537       190            mov     a, Seconds
015E B45924     191            cjne    a, #0x59, IncSeconds ; if Seconds != 59, then seconds++
0161 7400       192       mov          a, #0 
0163 D4         193       da           a
0164 F537       194       mov          Seconds, a
0166            195      
0166            196       
0166 308005     197            jnb UPDOWN, Timer2_ISR_decrement
0169 2401       198            add a, #0x01
016B 020170     199            ljmp Timer2_ISR_da
016E            200            
016E            201   Timer2_ISR_decrement:
016E 2499       202            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0170            203   Timer2_ISR_da:
0170 D4         204            da a ; Decimal adjust instruction.  Check datasheet for more details!
0171 F537       205            mov Seconds, a
0173            206            
0173            207   Timer2_ISR_done:
0173 D0D0       208            pop psw
0175 D0E0       209            pop acc
0177 32         210            reti
0178            211   
0178            212   IncTenthSeconds:
0178 2401       213            add a, #0x01
017A D4         214            da a
017B F536       215            mov TenthSeconds, a
017D B535C1     216            cjne a, PowerPercent, Inc_Done
0180 D2A2       217            setb OvenPin
0182 020141     218            ljmp Inc_Done
0185            219   
0185            220   IncSeconds:
0185 C2A2       221            clr OvenPin
0187 2401       222            add a, #0x01
0189 D4         223            da a
018A F537       224            mov Seconds, a
018C 020141     225            ljmp Inc_Done
018F            226            
018F            227   ;---------------------------------;
018F            228   ; Main program. Includes hardware ;
018F            229   ; initialization and 'forever'    ;
018F            230   ; loop.                           ;
018F            231   ;---------------------------------;
018F            232   main:
018F            233            ; Initialization
018F 75817F     234       mov SP, #0x7F
0192 1200FC     235       lcall Timer0_Init
0195 120118     236       lcall Timer2_Init
0198            237       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
0198 75E600     238       mov P0M0, #0
019B 75E700     239       mov P0M1, #0
019E 753505     240            mov PowerPercent, #5
01A1            241   
01A1 D2AF       242       setb EA  ; Enable Global interrupts
01A3 120088     243       lcall LCD_4BIT
01A6            244            
01A6            245       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
01A6 C0E0       246            push acc
01A8 7401       246            mov a, #1
01AA 14         246            dec a
01AB 1200BF     246            lcall ?Set_Cursor_1 ; Select column and row
01AE D0E0       246            pop acc
01B0 C083       247            push dph
01B2 C082       247            push dpl
01B4 C0E0       247            push acc
01B6 9000DA     247            mov dptr, #Initial_Message
01B9 1200B2     247            lcall ?Send_Constant_String
01BC D0E0       247            pop acc
01BE D082       247            pop dpl
01C0 D083       247            pop dph
01C2 D200       248       setb seconds_flag
01C4            249            ; After initialization the program stays in this 'forever' loop
01C4            250   loop:
01C4 0201C4     251            ljmp loop
01C7            252   
01C7            253   EN
