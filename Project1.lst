                  2   $LIST
0000              4   
0000              5   CLK           EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000              6   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000              7   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000              8   
0000              9   BOOT_BUTTON   equ P4.5
0000             10   UPDOWN        equ P0.0
0000             11   
0000             12   ; Reset vector
0000             13   org 0x0000
0000 02015A      14       ljmp main
0003             15   ; External interrupt 0 vector (not used in this code)
0003             16   org 0x0003
0003 32          17            reti
0004             18   ; External interrupt 1 vector (not used in this code)
0013             19   org 0x0013
0013 32          20            reti
0014             21   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             22   org 0x001B
001B 32          23            reti
001C             24   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             25   org 0x0023 
0023 32          26            reti
0024             27   ; Timer/Counter 2 overflow interrupt vector
002B             28   org 0x002B
002B 0200F5      29            ljmp Timer2_ISR
002E             30   
002E             31   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             32   dseg at 0x30
0030             33   Count1ms:     ds 2 ; Used to determine when 1/10 of a second has passed
0032             34   tenth_seconds: ds 1 ; Store tenth_seconds 
0033             35   seconds: ds 1 ; Stores seconds
0034             36   
0034             37   PowerPercent: ds 1 ; Power% for Oven, 1 = 10%, 2 = 20% ... 10 = 100%. Using PWM
0035             38   
0035             39   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0035             40   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             41   bseg
0000             42   tenth_seconds_flag: dbit 1 ; Set to one in the ISR every time 100 ms had passed
0001             43   
002E             44   cseg
002E             45   
002E             46   LCD_RS equ P3.2
002E             47   LCD_E  equ P3.3
002E             48   LCD_D4 equ P3.4
002E             49   LCD_D5 equ P3.5
002E             50   LCD_D6 equ P3.6
002E             51   LCD_D7 equ P3.7
002E             52   OvenPin equ p2.2
002E             53   
                 55   	$LIST
00DA             57   
00DA             58   ;    1234567890123456    <- This helps determine the location of the counter
00DA 3A00        59   Initial_Message:  db ':', 0
00DC             60   
00DC             61   ; Routine to initialize the ISR
00DC             62   ; for timer 2 
00DC             63   Timer2_Init:
00DC 75C800      64            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
00DF 75CDA9      65            mov TH2, #high(TIMER2_RELOAD)
00E2 75CC9A      66            mov TL2, #low(TIMER2_RELOAD)
00E5             67            ; Set the reload value
00E5 75CBA9      68            mov RCAP2H, #high(TIMER2_RELOAD)
00E8 75CA9A      69            mov RCAP2L, #low(TIMER2_RELOAD)
00EB             70            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
00EB E4          71            clr a
00EC F530        72            mov Count1ms+0, a
00EE F531        73            mov Count1ms+1, a
00F0             74            ; Enable the timer and interrupts
00F0 D2AD        75       setb ET2  ; Enable timer 2 interrupt
00F2 D2CA        76       setb TR2  ; Enable timer 2
00F4 22          77            ret
00F5             78   
00F5             79   ;---------------------------------;
00F5             80   ; ISR for timer 2                 ;
00F5             81   ;---------------------------------;
00F5             82   Timer2_ISR:
00F5 C2CF        83            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
00F7 B290        84            cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
00F9             85            
00F9             86            ; The two registers used in the ISR must be saved in the stack
00F9 C0E0        87            push acc
00FB C0D0        88            push psw
00FD             89            
00FD             90            ; Increment the 16-bit one mili second counter
00FD 0530        91            inc Count1ms+0    ; Increment the low 8-bits first
00FF E530        92            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0101 7002        93            jnz Inc_Done
0103 0531        94            inc Count1ms+1
0105             95   
0105             96   Inc_Done:
0105             97            ; Check if half second has passed
0105 E530        98            mov a, Count1ms+0
0107 B4644B      99            cjne a, #low(100), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
010A E531       100            mov a, Count1ms+1
010C B40046     101            cjne a, #high(100), Timer2_ISR_done
010F            102            
010F            103            ; 100 milliseconds have passed.  Set a flag so the main program knows
010F            104            
010F D200       105            setb tenth_seconds_flag ; Let the main program know 100 milliseconds have passed
0111            106            
0111 E4         107            clr a
0112 F530       108            mov Count1ms+0, a
0114 F531       109            mov Count1ms+1, a
0116            110   
0116            111   
0116            112            ;1/10 Seconds Increment
0116 E532       113            mov a, tenth_seconds
0118 B40916     114            cjne a, #0x9, IncTenthSeconds
011B 7400       115       mov a, #0 
011D D4         116       da a
011E F532       117       mov tenth_seconds, a
0120            118   
0120            119            ;Seconds Increment
0120 E533       120            mov     a, Seconds
0122 B45919     121       cjne         a, #0x59, IncSeconds ; if Seconds != 59, then seconds++
0125 7400       122       mov          a, #0 
0127 D4         123       da           a
0128 F533       124       mov          seconds, a
012A            125      
012A 308023     126            jnb UPDOWN, Timer2_ISR_decrement
012D 2401       127            add a, #0x01
012F 8021       128            sjmp Timer2_ISR_da
0131            129            
0131            130   IncTenthSeconds:
0131 2401       131            add a, #0x01
0133 D4         132            da a
0134 F532       133            mov tenth_seconds, a
0136 B534CC     134            cjne a, PowerPercent, Inc_Done
0139 D2A2       135            setb OvenPin
013B 020105     136            ljmp Inc_Done
013E            137   
013E            138   IncSeconds:
013E 2401       139            add a, #0x01
0140 D4         140            da a
0141 F533       141            mov seconds, a
0143 E534       142            mov a, PowerPercent
0145 B40003     143            cjne a, #0x00, OvenOn
0148 020105     144            ljmp Inc_Done
014B            145   
014B            146   OvenOn:
014B C2A2       147            clr OvenPin
014D 020105     148            ljmp Inc_Done
0150            149   
0150            150   Timer2_ISR_decrement:
0150 2499       151            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0152            152   
0152            153   Timer2_ISR_da:
0152 D4         154            da a
0153 F532       155            mov tenth_seconds, a
0155            156            
0155            157   Timer2_ISR_done:
0155 D0D0       158            pop psw
0157 D0E0       159            pop acc
0159 32         160            reti
015A            161   
015A            162   
015A            163   ; Main program. Includes hardware ;
015A            164   ; initialization and 'forever'    ;
015A            165   ; loop.                           ;
015A            166   main:
015A            167            ; Initialization
015A 75817F     168       mov SP, #0x7F
015D 1200DC     169       lcall Timer2_Init
0160            170       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
0160 75E600     171       mov P0M0, #0
0163 75E700     172       mov P0M1, #0
0166            173   
0166 753408     174            mov PowerPercent, #8 ;Power Percent Mode set, 0 = 0%, 1 = 10% ... 10 = 100%
0169 753200     175            mov tenth_seconds, #0
016C 753300     176            mov seconds, #0
016F            177   
016F D2AF       178       setb EA   ; Enable Global interrupts
0171 120088     179       lcall LCD_4BIT
0174            180   
0174            181       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
0174 C0E0       182            push acc
0176 7401       182            mov a, #1
0178 14         182            dec a
0179 1200BF     182            lcall ?Set_Cursor_1 ; Select column and row
017C D0E0       182            pop acc
017E D200       183       setb tenth_seconds_flag
0180            184            
0180            185            
0180            186            ; After initialization the program stays in this 'forever' loop
0180            187   loop:
0180 20C51C     188            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
0183 C002       189            push AR2
0185 7A32       189            mov R2, #50
0187 120039     189            lcall ?Wait_Milli_Seconds
018A D002       189            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
018C 20C510     190            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
018F 30C5FD     191            jnb BOOT_BUTTON, $              ; Wait for button release.  The '$' means: jump to same instruction.
0192            192            ; A valid press of the 'BOOT' button has been detected, reset the BCD counter.
0192            193            ; But first stop timer 2 and reset the milli-tenth_seconds counter, to resync everything.
0192 C2CA       194            clr TR2                 ; Stop timer 2
0194 E4         195            clr a
0195 F530       196            mov Count1ms+0, a
0197 F531       197            mov Count1ms+1, a
0199            198            ; Now clear the BCD counter
0199 F532       199            mov tenth_seconds, a
019B D2CA       200            setb TR2                ; Start timer 2
019D 8003       201            sjmp loop_b             ; Display the new value
019F            202   loop_a:
019F 3000DE     203            jnb tenth_seconds_flag, loop
01A2            204   loop_b:
01A2 C200       205       clr tenth_seconds_flag
01A4            206       
01A4 C0E0       207            push acc
01A6 7408       207            mov a, #8
01A8 14         207            dec a
01A9 1200BF     207            lcall ?Set_Cursor_1 ; Select column and row
01AC D0E0       207            pop acc
01AE C000       208            push ar0
01B0 A832       208            mov r0, tenth_seconds
01B2 1200C4     208            lcall ?Display_BCD
01B5 D000       208            pop ar0
01B7 C0E0       209            push acc
01B9 7406       209            mov a, #6
01BB 14         209            dec a
01BC 1200BF     209            lcall ?Set_Cursor_1 ; Select column and row
01BF D0E0       209            pop acc
01C1 C000       210            push ar0
01C3 A833       210            mov r0, seconds
01C5 1200C4     210            lcall ?Display_BCD
01C8 D000       210            pop ar0
01CA C0E0       211            push acc
01CC 7408       211            mov a, #8
01CE 14         211            dec a
01CF 1200BF     211            lcall ?Set_Cursor_1 ; Select column and row
01D2 D0E0       211            pop acc
01D4 C083       212            push dph
01D6 C082       212            push dpl
01D8 C0E0       212            push acc
01DA 9000DA     212            mov dptr, #Initial_Message
01DD 1200B2     212            lcall ?Send_Constant_String
01E0 D0E0       212            pop acc
01E2 D082       212            pop dpl
01E4 D083       212            pop dph
01E6 C0E0       213            push acc
01E8 7405       213            mov a, #5
01EA 14         213            dec a
01EB 1200BD     213            lcall ?Set_Cursor_2 ; Select column and row
01EE D0E0       213            pop acc
01F0 C000       214            push ar0
01F2 A834       214            mov r0, PowerPercent
01F4 1200C4     214            lcall ?Display_BCD
01F7 D000       214            pop ar0
01F9            215   
01F9 020180     216       ljmp loop
01FC            217   END
