                  2   $LIST
0000              4   
0000              5   CLK           EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000              6   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000              7   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000              8   
0000              9   BOOT_BUTTON   equ P4.5
0000             10   UPDOWN        equ P0.0
0000             11   
0000             12   ; Reset vector
0000             13   org 0x0000
0000 020152      14       ljmp main
0003             15   ; External interrupt 0 vector (not used in this code)
0003             16   org 0x0003
0003 32          17            reti
0004             18   ; External interrupt 1 vector (not used in this code)
0013             19   org 0x0013
0013 32          20            reti
0014             21   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             22   org 0x001B
001B 32          23            reti
001C             24   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             25   org 0x0023 
0023 32          26            reti
0024             27   ; Timer/Counter 2 overflow interrupt vector
002B             28   org 0x002B
002B 0200F5      29            ljmp Timer2_ISR
002E             30   
002E             31   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             32   dseg at 0x30
0030             33   Count1ms:     ds 2 ; Used to determine when 1/10 of a second has passed
0032             34   tenth_seconds: ds 1 ; Store tenth_seconds 
0033             35   seconds: ds 1 ; Stores seconds
0034             36   
0034             37   PowerPercent: ds 1 ; Power% for Oven, 1 = 10%, 2 = 20% ... 10 = 100%. Using PWM
0035             38   
0035             39   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0035             40   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             41   bseg
0000             42   tenth_seconds_flag: dbit 1 ; Set to one in the ISR every time 100 ms had passed
0001             43   
002E             44   cseg
002E             45   
002E             46   LCD_RS equ P3.2
002E             47   LCD_E  equ P3.3
002E             48   LCD_D4 equ P3.4
002E             49   LCD_D5 equ P3.5
002E             50   LCD_D6 equ P3.6
002E             51   LCD_D7 equ P3.7
002E             52   OvenPin equ p2.2
002E             53   
                 55   	$LIST
00DA             57   
00DA             58   ;    1234567890123456    <- This helps determine the location of the counter
00DA 3A00        59   Initial_Message:  db ':', 0
00DC             60   
00DC             61   ; Routine to initialize the ISR
00DC             62   ; for timer 2 
00DC             63   Timer2_Init:
00DC 75C800      64            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
00DF 75CDA9      65            mov TH2, #high(TIMER2_RELOAD)
00E2 75CC9A      66            mov TL2, #low(TIMER2_RELOAD)
00E5             67            ; Set the reload value
00E5 75CBA9      68            mov RCAP2H, #high(TIMER2_RELOAD)
00E8 75CA9A      69            mov RCAP2L, #low(TIMER2_RELOAD)
00EB             70            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
00EB E4          71            clr a
00EC F530        72            mov Count1ms+0, a
00EE F531        73            mov Count1ms+1, a
00F0             74            ; Enable the timer and interrupts
00F0 D2AD        75       setb ET2  ; Enable timer 2 interrupt
00F2 D2CA        76       setb TR2  ; Enable timer 2
00F4 22          77            ret
00F5             78   
00F5             79   ;---------------------------------;
00F5             80   ; ISR for timer 2                 ;
00F5             81   ;---------------------------------;
00F5             82   Timer2_ISR:
00F5 C2CF        83            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
00F7 B290        84            cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
00F9             85            
00F9             86            ; The two registers used in the ISR must be saved in the stack
00F9 C0E0        87            push acc
00FB C0D0        88            push psw
00FD             89            
00FD             90            ; Increment the 16-bit one mili second counter
00FD 0530        91            inc Count1ms+0    ; Increment the low 8-bits first
00FF E530        92            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0101 7002        93            jnz Inc_Done
0103 0531        94            inc Count1ms+1
0105             95   
0105             96   Inc_Done:
0105             97            ; Check if half second has passed
0105 E530        98            mov a, Count1ms+0
0107 B46443      99            cjne a, #low(100), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
010A E531       100            mov a, Count1ms+1
010C B4003E     101            cjne a, #high(100), Timer2_ISR_done
010F            102            
010F            103            ; 100 milliseconds have passed.  Set a flag so the main program knows
010F            104            
010F D200       105            setb tenth_seconds_flag ; Let the main program know 100 milliseconds have passed
0111            106            
0111 E4         107            clr a
0112 F530       108            mov Count1ms+0, a
0114 F531       109            mov Count1ms+1, a
0116            110   
0116            111   
0116            112            ;1/10 Seconds Increment
0116 E532       113            mov a, tenth_seconds
0118 B40916     114            cjne a, #0x9, IncTenthSeconds
011B 7400       115       mov a, #0 
011D D4         116       da a
011E F532       117       mov tenth_seconds, a
0120            118   
0120            119            ;Seconds Increment
0120 E533       120            mov     a, Seconds
0122 B45919     121       cjne         a, #0x59, IncSeconds ; if Seconds != 59, then seconds++
0125 7400       122       mov          a, #0 
0127 D4         123       da           a
0128 F533       124       mov          seconds, a
012A            125      
012A 30801B     126            jnb UPDOWN, Timer2_ISR_decrement
012D 2401       127            add a, #0x01
012F 8019       128            sjmp Timer2_ISR_da
0131            129            
0131            130   IncTenthSeconds:
0131 2401       131            add a, #0x01
0133 D4         132            da a
0134 F532       133            mov tenth_seconds, a
0136 B534CC     134            cjne a, PowerPercent, Inc_Done
0139 D2A2       135            setb OvenPin
013B 020105     136            ljmp Inc_Done
013E            137   
013E            138   IncSeconds:
013E C2A2       139            clr OvenPin
0140 2401       140            add a, #0x01
0142 D4         141            da a
0143 F533       142            mov seconds, a
0145 020105     143            ljmp Inc_Done
0148            144   
0148            145   Timer2_ISR_decrement:
0148 2499       146            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
014A            147   
014A            148   Timer2_ISR_da:
014A D4         149            da a
014B F532       150            mov tenth_seconds, a
014D            151            
014D            152   Timer2_ISR_done:
014D D0D0       153            pop psw
014F D0E0       154            pop acc
0151 32         155            reti
0152            156   
0152            157   
0152            158   ; Main program. Includes hardware ;
0152            159   ; initialization and 'forever'    ;
0152            160   ; loop.                           ;
0152            161   main:
0152            162            ; Initialization
0152 75817F     163       mov SP, #0x7F
0155 1200DC     164       lcall Timer2_Init
0158            165       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
0158 75E600     166       mov P0M0, #0
015B 75E700     167       mov P0M1, #0
015E            168   
015E 753401     169            mov PowerPercent, #1 ;Power Percent Mode set, 0 = 0%, 1 = 10% ... 10 = 100%
0161 753200     170            mov tenth_seconds, #0
0164 753300     171            mov seconds, #0
0167            172   
0167 D2AF       173       setb EA   ; Enable Global interrupts
0169 120088     174       lcall LCD_4BIT
016C            175   
016C            176       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
016C C0E0       177            push acc
016E 7401       177            mov a, #1
0170 14         177            dec a
0171 1200BF     177            lcall ?Set_Cursor_1 ; Select column and row
0174 D0E0       177            pop acc
0176 D200       178       setb tenth_seconds_flag
0178            179            
0178            180            
0178            181            ; After initialization the program stays in this 'forever' loop
0178            182   loop:
0178 20C51C     183            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
017B C002       184            push AR2
017D 7A32       184            mov R2, #50
017F 120039     184            lcall ?Wait_Milli_Seconds
0182 D002       184            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0184 20C510     185            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
0187 30C5FD     186            jnb BOOT_BUTTON, $              ; Wait for button release.  The '$' means: jump to same instruction.
018A            187            ; A valid press of the 'BOOT' button has been detected, reset the BCD counter.
018A            188            ; But first stop timer 2 and reset the milli-tenth_seconds counter, to resync everything.
018A C2CA       189            clr TR2                 ; Stop timer 2
018C E4         190            clr a
018D F530       191            mov Count1ms+0, a
018F F531       192            mov Count1ms+1, a
0191            193            ; Now clear the BCD counter
0191 F532       194            mov tenth_seconds, a
0193 D2CA       195            setb TR2                ; Start timer 2
0195 8003       196            sjmp loop_b             ; Display the new value
0197            197   loop_a:
0197 3000DE     198            jnb tenth_seconds_flag, loop
019A            199   loop_b:
019A C200       200       clr tenth_seconds_flag
019C            201       
019C C0E0       202            push acc
019E 7408       202            mov a, #8
01A0 14         202            dec a
01A1 1200BF     202            lcall ?Set_Cursor_1 ; Select column and row
01A4 D0E0       202            pop acc
01A6 C000       203            push ar0
01A8 A832       203            mov r0, tenth_seconds
01AA 1200C4     203            lcall ?Display_BCD
01AD D000       203            pop ar0
01AF C0E0       204            push acc
01B1 7406       204            mov a, #6
01B3 14         204            dec a
01B4 1200BF     204            lcall ?Set_Cursor_1 ; Select column and row
01B7 D0E0       204            pop acc
01B9 C000       205            push ar0
01BB A833       205            mov r0, seconds
01BD 1200C4     205            lcall ?Display_BCD
01C0 D000       205            pop ar0
01C2 C0E0       206            push acc
01C4 7408       206            mov a, #8
01C6 14         206            dec a
01C7 1200BF     206            lcall ?Set_Cursor_1 ; Select column and row
01CA D0E0       206            pop acc
01CC C083       207            push dph
01CE C082       207            push dpl
01D0 C0E0       207            push acc
01D2 9000DA     207            mov dptr, #Initial_Message
01D5 1200B2     207            lcall ?Send_Constant_String
01D8 D0E0       207            pop acc
01DA D082       207            pop dpl
01DC D083       207            pop dph
01DE            208   
01DE 020178     209       ljmp loop
01E1            210   END
